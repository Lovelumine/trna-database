1
00:00:11,359 --> 00:00:12,589
各位同学大家好

2
00:00:12,589 --> 00:00:17,089
我们今天学习的内容是双序列比对工具的介绍

3
00:00:17,089 --> 00:00:19,820
首先我们来进行一个简单的小游戏

4
00:00:19,820 --> 00:00:23,739
请找出左右两幅图片当中的若干差异

5
00:00:23,739 --> 00:00:25,239
非常的简单哈

6
00:00:25,239 --> 00:00:28,379
哪里不懂点哪里so easy

7
00:00:28,379 --> 00:00:30,899
那么下面我们进入第二个游戏

8
00:00:30,899 --> 00:00:35,768
请找出左右两个氨基酸序列当中的若干差异

9
00:00:35,768 --> 00:00:36,728
发现没有

10
00:00:36,728 --> 00:00:39,308
这对于我们肉眼寻找序列差异来讲

11
00:00:39,308 --> 00:00:40,789
是很困难的事情

12
00:00:40,789 --> 00:00:43,130
因此我们今天要学习的是

13
00:00:43,130 --> 00:00:46,670
如何利用计算机程序进行双序列比对

14
00:00:46,670 --> 00:00:50,295
我们称之为pairwise sequence alignment

15
00:00:51,520 --> 00:00:53,880
我们今天会用到的两个工具

16
00:00:53,880 --> 00:00:57,509
一个是来自于欧洲生物信息研究所

17
00:00:57,509 --> 00:01:01,409
简称EBI所开发的EMBOSS软件包

18
00:01:01,409 --> 00:01:05,489
第二个工具是来自于美国国立生物技术研究中心

19
00:01:05,489 --> 00:01:10,189
简称NCBI开发的一个BLAST软件包

20
00:01:10,189 --> 00:01:13,659
我们先来看一下EMBOSS软件包

21
00:01:14,180 --> 00:01:16,599
我们看到它的这个主界面

22
00:01:16,599 --> 00:01:20,599
左右两边各自给出了一个全局比对

23
00:01:20,599 --> 00:01:26,000
global alignment和局部比对local alignment的若干程序

24
00:01:26,000 --> 00:01:30,349
那么这两个刚好对应我们序列比对的两种方法

25
00:01:30,349 --> 00:01:32,810
一种是在1970年

26
00:01:32,810 --> 00:01:37,599
Needleman-Wunsch所开发的一种global全局比对的方法

27
00:01:37,599 --> 00:01:41,750
这种算法追求两个序列进行全局

28
00:01:41,750 --> 00:01:43,040
整体的一个比对

29
00:01:43,040 --> 00:01:47,599
那么它呢非常适用于寻找两个很高度相似的

30
00:01:47,599 --> 00:01:50,609
比如同源序列之间的一个比对

31
00:01:50,609 --> 00:01:52,829
接下来在1981年

32
00:01:52,829 --> 00:01:56,129
Smith-Waterman开发了一个local alignment算法

33
00:01:56,129 --> 00:01:57,829
我们称为局部比对

34
00:01:57,829 --> 00:02:01,730
这种算法并不追求两个序列整体的比对方法

35
00:02:01,730 --> 00:02:04,310
只是要求两个序列存在一个

36
00:02:04,310 --> 00:02:06,569
最优的局部比对即可

37
00:02:06,569 --> 00:02:10,650
那么这个呢非常适用于寻找两个基因之间

38
00:02:10,650 --> 00:02:15,965
存有高度同源或者是保守的这种功能域的情况

39
00:02:16,710 --> 00:02:17,210
好

40
00:02:17,210 --> 00:02:19,909
我们首先来看我们今天用到的是

41
00:02:19,909 --> 00:02:23,150
EMBOSS当中的一个Needleman-Wunsch算法

42
00:02:23,150 --> 00:02:24,949
也就是Needle软件

43
00:02:24,949 --> 00:02:29,509
我们点击它的一个蛋白序列之后

44
00:02:29,509 --> 00:02:32,810
我们进入看到这就是它的一个输入界面

45
00:02:32,810 --> 00:02:35,180
其中的两个输入框

46
00:02:35,180 --> 00:02:39,250
我们依次输入待比对的两条序列

47
00:02:39,250 --> 00:02:44,409
接下来点击屏幕下方的这个submit来进行提交

48
00:02:44,409 --> 00:02:46,490
结果很快出来

49
00:02:46,490 --> 00:02:50,300
我们先看屏幕下方的比对情况

50
00:02:50,300 --> 00:02:52,099
上下两条序列

51
00:02:52,099 --> 00:02:55,500
分别是我们输入的两条氨基酸序列

52
00:02:55,500 --> 00:02:57,750
那么中间的竖线和点

53
00:02:57,750 --> 00:03:00,838
对应的是每一个位置的比对情况

54
00:03:00,838 --> 00:03:02,399
举个例子

55
00:03:02,399 --> 00:03:05,278
两个一模一样的氨基酸

56
00:03:05,278 --> 00:03:07,528
中间用一条竖线连接起来

57
00:03:07,528 --> 00:03:09,699
我们称为一个match

58
00:03:10,219 --> 00:03:12,280
两个不一样的氨基酸

59
00:03:12,280 --> 00:03:14,110
中间用一个点表示

60
00:03:14,110 --> 00:03:16,399
我们称为mismatch

61
00:03:16,399 --> 00:03:18,288
那么第三种情况

62
00:03:18,288 --> 00:03:20,209
两个氨基酸虽然不一样

63
00:03:20,209 --> 00:03:23,370
但是它们具有很强的化学相似性

64
00:03:23,370 --> 00:03:28,259
我们用两个点连接起来称为similar

65
00:03:28,259 --> 00:03:31,439
那么因此我们可以了解上方的几个概念

66
00:03:31,439 --> 00:03:35,639
length长度表示的是我们两条序列的比对

67
00:03:35,639 --> 00:03:38,080
总长是142位

68
00:03:38,080 --> 00:03:40,849
第二个概念identity一致性

69
00:03:40,849 --> 00:03:44,810
那么它呢是说在这142位的比对当中

70
00:03:44,810 --> 00:03:48,610
完全一致的match占123位

71
00:03:48,610 --> 00:03:52,680
那么因此我们的identity是86.6%

72
00:03:52,680 --> 00:03:53,460
是的

73
00:03:53,460 --> 00:03:56,949
那么第三个概念similarity是相似性

74
00:03:56,949 --> 00:03:58,870
它包含两个部分

75
00:03:58,870 --> 00:04:03,439
一部分是我们刚才说的一模一样的match的个数

76
00:04:03,439 --> 00:04:08,419
另一部分是指的两个具有很强相似化学特征的

77
00:04:08,419 --> 00:04:11,000
也就是similar的这个位点的个数

78
00:04:11,000 --> 00:04:13,430
那么这两部分进行作和

79
00:04:13,430 --> 00:04:16,259
最终呢我们得到了131

80
00:04:16,259 --> 00:04:20,319
所以呢我们的similarity是92.3%

81
00:04:20,319 --> 00:04:22,120
好gaps的话呢

82
00:04:22,120 --> 00:04:25,600
是指我们整个的这样一个比对的当中

83
00:04:25,600 --> 00:04:28,908
并没有引入任何的插入或者删除

84
00:04:28,908 --> 00:04:30,528
所以我们的gaps是零

85
00:04:31,548 --> 00:04:35,629
最后呢我们重点来说一下score分值

86
00:04:36,449 --> 00:04:41,189
score分值的计算取决于每一个位点的比对情况

87
00:04:41,189 --> 00:04:43,800
而每个位点都有一个比对得分

88
00:04:43,800 --> 00:04:47,730
这个比对得分呢是取决于一个打分矩阵

89
00:04:47,730 --> 00:04:50,720
我们称为替代矩阵

90
00:04:50,720 --> 00:04:52,310
好我们来看第一个位点

91
00:04:52,310 --> 00:04:55,250
是一个天冬氨酸和精氨酸的比对

92
00:04:55,250 --> 00:05:00,579
那么我们来查替代矩阵当中的天冬氨酸和精氨酸

93
00:05:00,579 --> 00:05:01,930
得分一

94
00:05:01,930 --> 00:05:04,918
所以我们在第一个位点积分一

95
00:05:04,918 --> 00:05:09,629
下面看第二个位点两个亮氨酸之间的比对

96
00:05:09,629 --> 00:05:12,399
我们来查替代矩阵

97
00:05:12,399 --> 00:05:14,980
两个亮氨酸之间积分正四

98
00:05:14,980 --> 00:05:18,220
所以第二点计分正四

99
00:05:18,220 --> 00:05:19,240
以此类推

100
00:05:19,240 --> 00:05:22,428
当我们遇到一个gap空位的时候

101
00:05:22,428 --> 00:05:25,879
我们要查空位罚分规则

102
00:05:25,879 --> 00:05:28,279
我们看到第一次引入一个空位

103
00:05:28,279 --> 00:05:30,139
我们称为gap opening

104
00:05:30,139 --> 00:05:31,579
打开一个gap

105
00:05:31,579 --> 00:05:33,740
那么它的积分是四

106
00:05:33,740 --> 00:05:36,418
所以打开一个gap扣四分

107
00:05:36,418 --> 00:05:38,278
那么接下来我们延长

108
00:05:38,278 --> 00:05:41,158
也就是说连续的再接一个gap的时候

109
00:05:41,158 --> 00:05:43,459
我们称为gap extension

110
00:05:43,459 --> 00:05:44,839
空位延伸

111
00:05:44,839 --> 00:05:46,699
那么它呢积分一

112
00:05:46,699 --> 00:05:50,040
所以延伸一个gap再扣一分

113
00:05:50,040 --> 00:05:54,089
那么最终呢我们的score分值是每一个位点的

114
00:05:54,089 --> 00:05:58,600
这样一个score分值作和最后获得我们总的分值

115
00:05:58,600 --> 00:06:00,910
我们看到score分值的计算

116
00:06:00,910 --> 00:06:03,810
那么非常依赖于我们这个替代矩阵了

117
00:06:03,810 --> 00:06:06,449
我们在氨基酸的这个比对当中

118
00:06:06,449 --> 00:06:09,029
非常常用的两个替代矩阵

119
00:06:09,029 --> 00:06:10,970
一个是BLOSUM62

120
00:06:13,600 --> 00:06:15,819
下面我们来总结一下几个概念

121
00:06:15,819 --> 00:06:17,439
第一个是一致性

122
00:06:17,439 --> 00:06:20,158
它反映的是两个比对序列当中

123
00:06:20,158 --> 00:06:23,360
完全一致的氨基酸的个数

124
00:06:23,699 --> 00:06:25,310
第二个是相似性

125
00:06:25,310 --> 00:06:28,759
那么它呢反映的是两个比对当中的这种

126
00:06:28,759 --> 00:06:32,560
有相似的化学性质的这种氨基酸的个数

127
00:06:32,560 --> 00:06:34,660
最后是score分值

128
00:06:34,660 --> 00:06:37,329
它是所有位点比对分值的一个总和

129
00:06:37,329 --> 00:06:40,939
那么它的取值取决于一个是替代矩阵

130
00:06:40,939 --> 00:06:42,800
第二个是罚分规则

131
00:06:44,060 --> 00:06:46,819
好，学习完了EBI的EMBOSS工具之后

132
00:06:46,819 --> 00:06:49,680
我们来看第二个工具BLAST

133
00:06:49,680 --> 00:06:50,879
从它的名字上

134
00:06:50,879 --> 00:06:54,779
我们可以看出这是一个局部比对的程序

135
00:06:54,779 --> 00:06:57,589
好，进入BLAST的界面

136
00:06:57,589 --> 00:07:01,370
我们可以看到上方有五个标签栏

137
00:07:01,370 --> 00:07:06,620
我们这里选择BLASTP，对应的是比对两条蛋白序列

138
00:07:06,620 --> 00:07:10,918
那么BLASTN呢相应的是比对两条核苷酸序列

139
00:07:10,918 --> 00:07:12,178
其余的三位

140
00:07:12,178 --> 00:07:16,529
其余的三个大家呢可以课下再去了解

141
00:07:16,529 --> 00:07:18,959
依旧输入两个待比对序列之后

142
00:07:18,959 --> 00:07:21,720
我们展开下方的这个加号

143
00:07:21,720 --> 00:07:25,249
来看一下有哪些算法参数供我们选择

144
00:07:26,269 --> 00:07:26,869
展开之后

145
00:07:26,869 --> 00:07:28,189
我们首先来看一下

146
00:07:28,189 --> 00:07:30,449
这里有一个替代矩阵

147
00:07:30,970 --> 00:07:33,990
其中就包括我们刚才介绍的BLOSUM62

148
00:07:35,430 --> 00:07:36,060
好

149
00:07:36,060 --> 00:07:38,290
第二个我们来看罚分规则

150
00:07:38,290 --> 00:07:42,879
罚分规则当中就包括打开一个gap扣11分

151
00:07:42,879 --> 00:07:44,680
延伸一个gap扣一分

152
00:07:44,680 --> 00:07:48,730
大家也可以选择其他的参数自行测试一下

153
00:07:48,730 --> 00:07:52,860
最后我们点击屏幕最下方的BLAST按钮

154
00:07:52,860 --> 00:07:54,480
结果很快出来

155
00:07:54,480 --> 00:07:57,120
我们可以看到一个match

156
00:07:57,120 --> 00:08:00,490
反映的是两个完全一致的氨基酸

157
00:08:00,889 --> 00:08:04,089
同样一个mismatch中间的空位

158
00:08:04,089 --> 00:08:07,379
反映的是两个不一致的氨基酸

159
00:08:07,779 --> 00:08:10,680
那么一个similar用一个加号来表示

160
00:08:10,680 --> 00:08:14,209
反映的是两个具有相似化学性质的氨基酸

161
00:08:14,209 --> 00:08:19,670
这样我们刚才的几个概念可以完全的套用过来

162
00:08:19,670 --> 00:08:23,240
我们的gap similarity就是positive

163
00:08:23,240 --> 00:08:25,680
跟identity是一致的

164
00:08:25,680 --> 00:08:29,100
最后我们来看一下这里的score分值

165
00:08:29,100 --> 00:08:32,549
在BLAST当中把score分值进行了一个转换

166
00:08:32,549 --> 00:08:34,629
我们称为bit score

167
00:08:34,629 --> 00:08:39,370
它这个分值是将原有的分值进行了一个log scale

168
00:08:39,370 --> 00:08:42,038
也就是对它进行了一个标准化

169
00:08:42,038 --> 00:08:43,479
获得的这个总的

170
00:08:43,479 --> 00:08:46,328
最后的得分是一个转换后的分值

171
00:08:46,328 --> 00:08:49,178
也就是我们这里看到的255分

172
00:08:49,178 --> 00:08:51,349
实际上是一个bit score

173
00:08:51,349 --> 00:08:54,759
最后我们重点来讲一下E-value

174
00:08:54,759 --> 00:08:56,139
E-value值呢

175
00:08:56,139 --> 00:08:56,679
说的是

176
00:08:56,679 --> 00:08:58,539
当我们获得255分

177
00:08:58,539 --> 00:09:00,759
这样一个bit score的情况下

178
00:09:00,759 --> 00:09:04,659
那么它有多少的可能性是由随机情况造成的

179
00:09:04,659 --> 00:09:07,019
我们举一个例子

180
00:09:07,480 --> 00:09:08,340
数学上啊

181
00:09:08,340 --> 00:09:12,230
有一个非常重要的一个公式

182
00:09:12,230 --> 00:09:14,779
有一个定律叫做无限猴子定律

183
00:09:14,779 --> 00:09:17,370
他说的是在无尽的时间里

184
00:09:17,370 --> 00:09:19,049
有无限多的猴子

185
00:09:19,049 --> 00:09:22,379
任意随机敲击这样一个打字机的话

186
00:09:22,379 --> 00:09:24,389
那么在足够长的时间里

187
00:09:24,389 --> 00:09:28,009
他们一定可以敲出莎士比亚全集

188
00:09:28,009 --> 00:09:29,899
这个事件说明的是

189
00:09:29,899 --> 00:09:31,299
当时间无限

190
00:09:31,299 --> 00:09:33,039
空间无限的情况下

191
00:09:33,039 --> 00:09:36,220
那么由随机情况下造成的小概率事件

192
00:09:36,220 --> 00:09:38,000
是必然会发生的

193
00:09:38,000 --> 00:09:40,039
我们把这个实验做一个更改

194
00:09:41,360 --> 00:09:43,909
假设我们有500万只猴子

195
00:09:43,909 --> 00:09:49,820
那么每人发一台最新的MacBook Air给他们一年的时间

196
00:09:49,820 --> 00:09:53,470
让我们来看这些猴子会创作出什么样的大作

197
00:09:53,470 --> 00:09:55,149
我们没有做这个实验

198
00:09:55,149 --> 00:09:58,059
但是我们可以期待有多少只猴子

199
00:09:58,059 --> 00:10:01,029
大家猜测可以打出“hi”这样一个单词

200
00:10:01,029 --> 00:10:04,389
我们可以期待也许有那么十只猴子

201
00:10:04,389 --> 00:10:05,740
它们非常的lucky

202
00:10:05,740 --> 00:10:07,509
在随机敲击的情况下

203
00:10:07,509 --> 00:10:11,370
就可以创作出“hi”这样一个单词

204
00:10:11,370 --> 00:10:12,179
第二个的话

205
00:10:12,179 --> 00:10:13,049
“Hamlet”

206
00:10:13,049 --> 00:10:15,179
这是一个稍微复杂点的单词

207
00:10:15,179 --> 00:10:17,129
但是我们仍然有所期待

208
00:10:17,129 --> 00:10:19,950
我们想至少有一到两只猴子

209
00:10:19,950 --> 00:10:21,990
也许能够完全凭借随机

210
00:10:21,990 --> 00:10:23,328
它们very lucky

211
00:10:23,328 --> 00:10:26,149
可以完全凭借随机情况打出“Hamlet”

212
00:10:26,149 --> 00:10:28,379
这样一个单词

213
00:10:28,379 --> 00:10:32,149
第三个“to be or not to be, that's the question”

214
00:10:32,149 --> 00:10:35,299
我们几乎不对这些猴子做任何的期待

215
00:10:35,299 --> 00:10:36,470
因为我们相信

216
00:10:36,470 --> 00:10:40,649
这几乎不可能是由一个随机事件造成的结果

217
00:10:40,649 --> 00:10:44,240
大家看到我们所谓的这个期待值是说

218
00:10:44,240 --> 00:10:45,769
如果我们越低的话

219
00:10:45,769 --> 00:10:46,940
E-value越小

220
00:10:46,940 --> 00:10:50,419
将意味着这件事情是由随机情况造成的

221
00:10:50,419 --> 00:10:52,029
可能性就越低

222
00:10:52,029 --> 00:10:54,759
同样BLAST也是这样定义的

223
00:10:54,759 --> 00:10:59,568
BLAST E-value指的是在固定数据库搜索空间的情况下

224
00:10:59,568 --> 00:11:01,849
在获得同样的数据

225
00:11:01,849 --> 00:11:05,629
获得同样的比对个数是由随机情况下造成的

226
00:11:05,629 --> 00:11:07,960
我们对它的期望有多高

227
00:11:08,240 --> 00:11:10,120
好，我们一般文献认为

228
00:11:10,120 --> 00:11:13,090
小于1e-4就是一个可信的结果

229
00:11:13,090 --> 00:11:15,950
因为它呢，我们看到它的错误率

230
00:11:15,950 --> 00:11:19,889
几乎是小于0.01%的一个数值

231
00:11:19,889 --> 00:11:22,529
那么下面我们来看我们的这个比对分值

232
00:11:22,529 --> 00:11:23,879
E-value非常的小

233
00:11:23,879 --> 00:11:25,649
只有2e-92

234
00:11:25,649 --> 00:11:29,049
可见这是一个十分可信的结果

235
00:11:29,570 --> 00:11:32,710
好，最后我们总结一下今天这两个概念

236
00:11:32,710 --> 00:11:36,980
Bit score是一个标准化之后的score分值

237
00:11:37,379 --> 00:11:40,519
E-value是一个对于随机情况下

238
00:11:40,519 --> 00:11:43,318
造成同样结果的一种期望值

239
00:11:43,318 --> 00:11:46,198
那我们同样给出两个公式

240
00:11:46,198 --> 00:11:49,409
大家可以课后再去了解

241
00:11:49,870 --> 00:11:52,769
最后我们对今天所有的内容做一个总结

242
00:11:52,769 --> 00:11:56,220
首先我们今天学习到的双序列比对

243
00:11:56,220 --> 00:11:58,200
它呢是一个用于比对

244
00:11:58,200 --> 00:12:02,429
两条核苷酸或者是氨基酸序列的一种工具

245
00:12:02,769 --> 00:12:05,850
第二点我们学到了两种比对方法

246
00:12:05,850 --> 00:12:08,009
一种叫做局部比对

247
00:12:08,009 --> 00:12:10,840
第二种叫做全局比对

248
00:12:10,840 --> 00:12:13,720
接下来我们用了两个实际的工具

249
00:12:13,720 --> 00:12:15,519
一个是EMBOSS

250
00:12:15,519 --> 00:12:17,009
一个是BLAST

251
00:12:17,009 --> 00:12:19,799
最后我们学习到了一系列的参数

252
00:12:19,799 --> 00:12:21,539
它们非常的重要

253
00:12:21,539 --> 00:12:23,429
分别是一致性

254
00:12:23,429 --> 00:12:25,289
相似性、比对

255
00:12:25,289 --> 00:12:27,470
分值、替代矩阵

256
00:12:27,470 --> 00:12:29,090
空位罚分规则

257
00:12:29,090 --> 00:12:32,109
以及最后我们的E-value

258
00:12:32,568 --> 00:12:35,078
最后我们给大家留两个课后作业

259
00:12:35,078 --> 00:12:38,198
首先我们今天学习了BLAST

260
00:12:38,198 --> 00:12:39,589
了解了BLASTN

261
00:12:39,589 --> 00:12:43,129
请同学们去自行了解另外三个

262
00:12:43,129 --> 00:12:46,840
尝试一下另外三个工具起什么样的作用

263
00:12:46,840 --> 00:12:49,419
第二个请大家课后做一个思考

264
00:12:49,419 --> 00:12:52,210
我们的全局比对和局部比对

265
00:12:52,210 --> 00:12:54,940
各自是如何实现的

266
00:12:54,940 --> 00:12:56,649
它的算法是怎样的

267
00:12:56,649 --> 00:12:59,250
我们将在下一堂课进行介绍

268
00:12:59,250 --> 00:13:02,070
最后给出我们今天所有的参考文献

269
00:13:03,149 --> 00:13:04,399
谢谢大家
